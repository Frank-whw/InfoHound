# ğŸ“° InfoHound - 2026å¹´2æœˆ26æ—¥æ˜ŸæœŸå››

> ä»Šæ—¥ç²¾é€‰ 2 ç¯‡æ–‡ç« ï¼Œé¢„è®¡é˜…è¯»æ—¶é—´ 3 åˆ†é’Ÿ

---

## ğŸŒŸ å¤´æ¡

### Google API keys weren't secrets, but then Gemini changed the rules
**æ¥æº**: Hacker News | **è¯„åˆ†**: 8.5/10 ğŸŸ¡

**ä¸ºä»€ä¹ˆé‡è¦**: Thousands of organizations unknowingly have publicly exposed API keys that attackers can now use to steal private data and rack up massive AI bills, because Google retroactively turned decade-old 'non-secret' keys into sensitive credentials without warning developers.

**ä¸€å¥è¯æ€»ç»“**: Google's Gemini API silently granted sensitive access privileges to existing public API keys that Google had explicitly told developers were safe to embed in client-side code, creating a widespread privilege escalation vulnerability affecting nearly 3,000 exposed keys including Google's own.

**å…³é”®è¦ç‚¹**:
â€¢ Google spent over a decade documenting that API keys (AIza...) were 'not secrets' and safe for public client-side embedding in Maps, Firebase, and other services, designed only as billing identifiers with bypassable restrictions.
â€¢ When Gemini launched, any API key in an enabled project automatically gained access to sensitive endpoints (/files, /cachedContents) with no warning, notification, or confirmationâ€”turning public billing tokens into live authentication credentials for private data access.
â€¢ Researchers found 2,863 live exposed keys in the November 2025 Common Crawl, including keys from major financial institutions, security companies, and Google itself; one Google product key had been public since February 2023 and could access Gemini's /models endpoint.
â€¢ Attackers can exploit this by simply viewing page source, extracting the AIza... key, and calling Gemini endpoints to access uploaded files, cached data, exhaust quotas, or generate thousands of dollars in daily chargesâ€”all without touching victim infrastructure.
â€¢ Google initially dismissed the report as 'intended behavior' but reclassified it as a Tier 1 'Single-Service Privilege Escalation' bug after researchers provided proof-of-concept using Google's own exposed keys; remediation includes leaked key blocking and scoped defaults for new keys.

**èƒŒæ™¯**: This vulnerability stems from Google Cloud's architectural decision to use a single key format (AIza...) for two incompatible purposes: public project identification (Maps, Firebase) and sensitive authentication (Gemini). When the Generative Language API was introduced, it inherited this key infrastructure without implementing the standard security pattern of separate 'publishable' vs. 'secret' keys used by Stripe and other platforms. The insecure default of 'Unrestricted' API access combined with silent retroactive privilege expansion created a systemic vulnerability affecting any organization that followed Google's long-standing documentation for client-side API key deployment.

**æ ‡ç­¾**: Security, API, Google Cloud, Privilege Escalation

[é˜…è¯»åŸæ–‡](https://trufflesecurity.com/blog/google-api-keys-werent-secrets-but-then-gemini-changed-the-rules)


---

## ğŸ”¥ æ·±åº¦æŠ€æœ¯

### ğŸŸ¡ Against Query Based Compilers
**æ¥æº**: Lobste.rs | **è¯„åˆ†**: 7.5/10

**ä¸ºä»€ä¹ˆé‡è¦**: This article challenges the prevailing wisdom that query-based compilers are always the right solution, offering concrete architectural alternatives that can yield simpler, faster incremental compilationâ€”critical knowledge for anyone building or optimizing language tooling.

**è¦ç‚¹**:
â€¢ Query-based compilers rely on 'early cutoff' optimization to avoid recomputation, but their effectiveness is fundamentally bounded by the dependency structure of the source languageâ€”languages with 'avalanche' properties (like Rust's trait system or macros) force O(N) updates for O(1) changes regardless of the incremental framework used.
â€¢ Zig demonstrates an alternative: by designing the language so files can be parsed and name-resolved independently (no implicit imports, no macros generating code), Zig pushes queries far down the pipeline, achieving better performance with simpler architecture.
â€¢ Rust exemplifies the worst case: macros require name resolution during parsing, and trait impls can appear anywhere, forcing fine-grained dependency tracking from the very start of compilation and creating dependencies on 'non-existence of conflicting impls' across the entire codebase.

[é˜…è¯»åŸæ–‡](https://matklad.github.io/2026/02/25/against-query-based-compilers.html)


---

## ğŸ“Š ä»Šæ—¥ç»Ÿè®¡

| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| æ–‡ç« æ€»æ•° | 2 ç¯‡ |
| å¹³å‡è´¨é‡åˆ† | 8/10 |
| é¢„è®¡é˜…è¯»æ—¶é—´ | 3 åˆ†é’Ÿ |

---

*ç”± [InfoHound](https://github.com/Frank-whw/InfoHound) è‡ªåŠ¨ç”Ÿæˆ | AI æ•´ç†ï¼Œäººå·¥é˜…è¯»*
