<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>InfoHound - 2026å¹´2æœˆ26æ—¥æ˜ŸæœŸå››</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      max-width: 680px;
      margin: 0 auto;
      padding: 20px;
      color: #333;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1 { color: #1a1a1a; font-size: 28px; margin-bottom: 8px; }
    .subtitle { color: #666; font-size: 14px; margin-bottom: 30px; }
    .headline { background: #f8f9fa; padding: 24px; border-radius: 8px; margin: 24px 0; }
    .section { margin: 32px 0; }
    .section-title { font-size: 20px; color: #1a1a1a; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid #e9ecef; }
    .article { margin: 20px 0; padding: 16px; border-left: 4px solid #dee2e6; }
    .article.tech-deep { border-left-color: #2563eb; }
    .article.product { border-left-color: #f59e0b; }
    .article.ai { border-left-color: #8b5cf6; }
    .article.chinese { border-left-color: #10b981; }
    .article-title { font-size: 16px; font-weight: 600; margin-bottom: 8px; }
    .article-meta { font-size: 12px; color: #6b7280; margin-bottom: 8px; }
    .article-summary { font-size: 14px; color: #4b5563; margin-bottom: 12px; }
    .key-points { margin: 12px 0; padding-left: 16px; }
    .key-points li { margin: 4px 0; font-size: 14px; color: #374151; }
    .level-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-right: 8px; }
    .level-beginner { background: #d1fae5; color: #065f46; }
    .level-advanced { background: #fef3c7; color: #92400e; }
    .level-expert { background: #fee2e2; color: #991b1b; }
    .tags { margin-top: 8px; }
    .tag { display: inline-block; padding: 2px 8px; background: #f3f4f6; border-radius: 4px; font-size: 11px; color: #6b7280; margin-right: 4px; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .stats { background: #f8f9fa; padding: 16px; border-radius: 8px; margin-top: 24px; }
    .stats table { width: 100%; font-size: 14px; }
    .stats td { padding: 4px 0; }
    .footer { text-align: center; margin-top: 32px; padding-top: 24px; border-top: 1px solid #e5e7eb; font-size: 12px; color: #9ca3af; }
    @media (max-width: 600px) {
      body { padding: 10px; }
      .container { padding: 20px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ“° InfoHound</h1>
    <p class="subtitle">2026å¹´2æœˆ26æ—¥æ˜ŸæœŸå›› Â· ä»Šæ—¥ç²¾é€‰ 2 ç¯‡ Â· é¢„è®¡é˜…è¯» 3 åˆ†é’Ÿ</p>

    
    <div class="headline article tech-deep">
      <div class="article-title">Google API keys weren't secrets, but then Gemini changed the rules</div>
      <div class="article-meta">æ¥æº: Hacker News Â· è¯„åˆ†: 8.5/10 <span class="level-badge level-advanced">advanced</span></div>
      <div class="article-summary"><strong>ä¸ºä»€ä¹ˆé‡è¦:</strong> Thousands of organizations unknowingly have publicly exposed API keys that attackers can now use to steal private data and rack up massive AI bills, because Google retroactively turned decade-old 'non-secret' keys into sensitive credentials without warning developers.</div>
      <ul class="key-points">
        <li>Google spent over a decade documenting that API keys (AIza...) were 'not secrets' and safe for public client-side embedding in Maps, Firebase, and other services, designed only as billing identifiers with bypassable restrictions.</li><li>When Gemini launched, any API key in an enabled project automatically gained access to sensitive endpoints (/files, /cachedContents) with no warning, notification, or confirmationâ€”turning public billing tokens into live authentication credentials for private data access.</li><li>Researchers found 2,863 live exposed keys in the November 2025 Common Crawl, including keys from major financial institutions, security companies, and Google itself; one Google product key had been public since February 2023 and could access Gemini's /models endpoint.</li><li>Attackers can exploit this by simply viewing page source, extracting the AIza... key, and calling Gemini endpoints to access uploaded files, cached data, exhaust quotas, or generate thousands of dollars in daily chargesâ€”all without touching victim infrastructure.</li><li>Google initially dismissed the report as 'intended behavior' but reclassified it as a Tier 1 'Single-Service Privilege Escalation' bug after researchers provided proof-of-concept using Google's own exposed keys; remediation includes leaked key blocking and scoped defaults for new keys.</li>
      </ul>
      <div class="tags"><span class="tag">Security</span><span class="tag">API</span><span class="tag">Google Cloud</span><span class="tag">Privilege Escalation</span></div>
      <p><a href="https://trufflesecurity.com/blog/google-api-keys-werent-secrets-but-then-gemini-changed-the-rules" target="_blank">é˜…è¯»åŸæ–‡ â†’</a></p>
    </div>
    

    
    <div class="section">
      <div class="section-title">ğŸ”¥ æ·±åº¦æŠ€æœ¯</div>
      
    <div class="article tech-deep">
      <div class="article-title">Against Query Based Compilers</div>
      <div class="article-meta">æ¥æº: Lobste.rs Â· è¯„åˆ†: 7.5/10 <span class="level-badge level-advanced">advanced</span></div>
      <div class="article-summary"><strong>ä¸ºä»€ä¹ˆé‡è¦:</strong> This article challenges the prevailing wisdom that query-based compilers are always the right solution, offering concrete architectural alternatives that can yield simpler, faster incremental compilationâ€”critical knowledge for anyone building or optimizing language tooling.</div>
      <ul class="key-points">
        <li>Query-based compilers rely on 'early cutoff' optimization to avoid recomputation, but their effectiveness is fundamentally bounded by the dependency structure of the source languageâ€”languages with 'avalanche' properties (like Rust's trait system or macros) force O(N) updates for O(1) changes regardless of the incremental framework used.</li><li>Zig demonstrates an alternative: by designing the language so files can be parsed and name-resolved independently (no implicit imports, no macros generating code), Zig pushes queries far down the pipeline, achieving better performance with simpler architecture.</li><li>Rust exemplifies the worst case: macros require name resolution during parsing, and trait impls can appear anywhere, forcing fine-grained dependency tracking from the very start of compilation and creating dependencies on 'non-existence of conflicting impls' across the entire codebase.</li>
      </ul>
      <div class="tags"><span class="tag">Compilers</span><span class="tag">Incremental Compilation</span><span class="tag">Programming Languages</span><span class="tag">IDE</span></div>
      <p><a href="https://matklad.github.io/2026/02/25/against-query-based-compilers.html" target="_blank">é˜…è¯»åŸæ–‡ â†’</a></p>
    </div>
    
    </div>
    

    <div class="stats">
      <table>
        <tr><td>æ–‡ç« æ€»æ•°</td><td><strong>2 ç¯‡</strong></td></tr>
        <tr><td>å¹³å‡è´¨é‡åˆ†</td><td><strong>8/10</strong></td></tr>
        <tr><td>é¢„è®¡é˜…è¯»æ—¶é—´</td><td><strong>3 åˆ†é’Ÿ</strong></td></tr>
      </table>
    </div>

    <div class="footer">
      <p>ç”± <a href="https://github.com/Frank-whw/InfoHound">InfoHound</a> è‡ªåŠ¨ç”Ÿæˆ Â· AI æ•´ç†ï¼Œäººå·¥é˜…è¯»</p>
    </div>
  </div>
</body>
</html>